<!doctype html>
<html lang="en">
<head>
<title>6eea9878</title>
<meta name="generator" content="Etherpad">
<meta name="author" content="Etherpad">
<meta name="changedby" content="Etherpad">
<meta charset="utf-8">
<style>
* {
  font-family: arial, sans-serif;
  font-size: 13px;
  line-height: 17px;
}
ul.indent {
  list-style-type: none;
}
ol {
  list-style-type: none;
  padding-left: 0;
}
body > ol {
  counter-reset: first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth thirteenth fourteenth fifteenth sixteenth;
}
ol > li:before {
  content: counter(first) ". ";
  counter-increment: first;
}
ol > ol > li:before {
  content: counter(first) "." counter(second) ". ";
  counter-increment: second;
}
ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) ". ";
  counter-increment: third;
}
ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) ". ";
  counter-increment: fourth;
}
ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) ". ";
  counter-increment: fifth;
}
ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) ". ";
  counter-increment: sixth;
}
ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) ". ";
  counter-increment: seventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) ". ";
  counter-increment: eighth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) ". ";
  counter-increment: ninth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) ". ";
  counter-increment: tenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) ". ";
  counter-increment: eleventh;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelfth) ". ";
  counter-increment: twelfth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelfth) "." counter(thirteenth) ". ";
  counter-increment: thirteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelfth) "." counter(thirteenth) "." counter(fourteenth) ". ";
  counter-increment: fourteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelfth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) ". ";
  counter-increment: fifteenth;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > li:before {
  content: counter(first) "." counter(second) "." counter(third) "." counter(fourth) "." counter(fifth) "." counter(sixth) "." counter(seventh) "." counter(eighth) "." counter(ninth) "." counter(tenth) "." counter(eleventh) "." counter(twelfth) "." counter(thirteenth) "." counter(fourteenth) "." counter(fifteenth) "." counter(sixteenth) ". ";
  counter-increment: sixteenth;
}
ol {
  text-indent: 0px;
}
ol > ol {
  text-indent: 10px;
}
ol > ol > ol {
  text-indent: 20px;
}
ol > ol > ol > ol {
  text-indent: 30px;
}
ol > ol > ol > ol > ol {
  text-indent: 40px;
}
ol > ol > ol > ol > ol > ol {
  text-indent: 50px;
}
ol > ol > ol > ol > ol > ol > ol {
  text-indent: 60px;
}
ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 70px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 80px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 90px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 100px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 110px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 120px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 130px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 140px;
}
ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol > ol {
  text-indent: 150px;
}

</style>
</head>
<body>
<strong><u>CLASE 1</u></strong><br><br><strong>this</strong>: La instancia actual.<br><strong>public</strong>: Lo pueden usar todos.<br><strong>private</strong>: Solo puede usarlo la instancia del objeto.<br><br><strong>Memoria</strong>: STACK y HEAP y static.<br><strong>Variables locales</strong> ---&gt; Stack<br><strong>Instancias de objetos</strong> ---&gt; heap<br><strong>Referencias</strong> ---&gt; stack (especie de puntero al objeto).<br><br>Los pasajes de parametros son por valor en java<br>Variables locales a metodos deben inicializarse explicitamente sino se te hace mierda el programa<br><br><strong>Wrappers</strong>: Sirven para manejar datos de tipo primitivo como objetos.<br><ul class="bullet"><li>Son inmutables: para cambiar el valor se crea un nuevo objeto.</li><li>Trabajar con tipos primitivos es mas r&#225;pido que con un wrapper.</li><li><strong>Ejemplos</strong>: <em>char -&gt; Character</em> &#x2F; <em>int -&gt; Integer</em>.</ul><br>Java no es puramente orientado a objetos porque tiene los tipos primitivos.<br><br><strong>No usar versiones anteriores a J2SE 5.0 o la van a cagar.</strong><br><br><strong>Creacion e inicializacion:</strong><br><ol class="number"><li>Espacio en stack para variable.</li><li>Espacio en heap para objeto.</li><li>Inicializacion de atributos.</li><li>Constructor.</li><li>Se asigna referencia de objeto a la variable.</ol><br>(constructor por defecto <em>nombre_clase();</em> sin parametros)<br><br>memoria stack guarda las variables en contexto de donde se ejecutan, pueden haber varias al mismo tiempo, pero son disjuntas<br>memoria heap es la compartida!<br><br>manipular objeto (mandar mensaje a obj)<br>nombredelobjeto.metododelobjeto(parametros);<br><br><ul class="bullet"><li><strong>Variables de instancia:</strong> Fuera del m&#233;todo.</li><li><strong>Variables locales</strong>: Adentro del m&#233;todo.<ul class="bullet"><li>Las variables que son locales al m&#233;todo, cuando el m&#233;todo termina se eliminan de la memoria stack.</ul></li></ul><br><strong>static </strong>declara atributos y metodos asociados con la clase y son compartidas por todas las instancias de la misma clase<br><br><strong>Arreglos:</strong><br><ul class="bullet"><li><strong>En memoria</strong>: length, indices(de 0 a length-1) y datos.</li><li>Guarda valores de un mismo tipo.</ul><br><strong>For-each:</strong> nueva forma de recoorer un arreglo completo.<br><strong>Instrucci&#243;n:</strong><em> </em><strong>for (</strong><em>int &quot;nombre_variable&quot;</em><strong>:</strong><em> &quot;nombre_arreglo&quot;</em><strong>)</strong>.<br><ul class="bullet"><li>Se lee: Para cada elemento &quot;<em>nombre_variable</em>&quot; del tipo int (en este caso es int, pero puede ser otro) en el arreglo <em>nombre_arreglo</em>.</ul><br>-------------------------------------------------------------<br><br><strong><u>CLASE 2</u></strong><br><br><strong>Pasaje de par&#225;metros</strong><br><br>Por Java los par&#225;metros se pasan siempre por valor.<br><br>El pasaje de p&#225;rametros &quot;por referencia&quot; debe hacerse pasando referencias a objetos.<br><br>Wrapper y string son inmutables.<br><br>Es decir, si a una funci&#243;n se le pasa un par&#225;metro de tipo primitivo, wrapper o String, las modificaciones a los mismos dentro de la funci&#243;n no tendr&#225;n efecto una vez terminada la funci&#243;n; en cambio, los objetos s&#237; se ven afectados por los cambios dentro de la misma.<br><br><strong>El return:</strong><br>Si se usa un return, no hay problema con primitivos, wrappers o strings, a diferencia de m&#233;todos void&nbsp; donde no te va a retornar los valores modificados por que es por valor y no por referencia. Usando return ya lo que devuelve es un objeto nuevo.<br>Usar return es m&#225;s seguro.<br><br>diferencia entre metodo de clase y de instancia<br><br>Los m&#233;todos de clase se pueden llamar sin instancias (ejemplo: constructores), las instancias son para cuando necesito tener la posibilidad de tener varias instancias de un objeto(ejemplo getter y setter).<br><br>JAVA <u>SOLO</u> PERMITE HERENCIA SIMPLE<br><br>el this.variable; solo se usa en un metodo de instancia. Pero nunca en metodos de clase.<br><br>Cuando se carga una clase a memoria?<br>instancia:<br>Contacto c = new Contacto() - se carga cuando instancio.<br>Clase:<br>Math.PI lo estatico se carg cuando se carga la clase, cuando hago uso de algun metodo o variable de clase.<br><br>ejemplo:<br>clases static<br>variables static<br><br>public class Math {<br>public static double PI = 3.1416: }<br>public static final double PI = 3.1416;<br><br>Static es de clase.<br>Un ejemplo es con los contactos de tel&#233;fono. La ID de cada usuario se calculaba sumandole 1 a una variable static que todos los objetos contactos compart&#237;an, y siempre devolv&#237;a el &#250;ltimo ID registrado.<br><br><strong>HERENCIA</strong><br>La herencia toma una clase existente y construye una version especializada.<br><ul class="bullet"><li>El principal beneficio es la reusabilidad de c&#243;digo.</li><li>Una subclase puede reemplazar o modificar el comportamiento heredado.</ul><br><strong>Instancia de superclase:</strong> invoco m&#233;todos de la superclase.<br><strong>Instancia de subclase:</strong> invoco m&#233;todos de la subclase y los p&#250;blicos de la superclase.<br><br><strong>SOBREESCRITURA DE CLASES:</strong><br>La subclase tiene un m&#233;todo con el mismo encabezado (nombre, tipo de par&#225;metros, etc) que una de la superclase pero con el cuerpo diferente, espec&#237;fico a la subclase.<br><br><strong>Super.</strong> :&nbsp; Se usa para invocar m&#233;todos de la clase inmediatamente superior.&nbsp;<br><ul class="bullet"><li>Por ejemplo:<em>super.toString();</em></ul><strong>This. </strong>: el this lo usan solo para objetos instanciados sino la van a RECONTRA CAGAR (no es correcto)<br><br><strong>Upcasting</strong><br><ul class="bullet"><li>El objeto recuerda qu&#233; tipo es.</li><li>Solo puede invocar metodos de la superclase.</ul><br><em>vehiculo v = new auto();</em><br>Es un <em>auto </em>pero solo puede invocar a los m&#233;todos de <em>vehiculo</em>.<br><br><strong>Upcasting automatico:</strong><br><em>public void name(vehiculo v) {...}</em><br><br>Este m&#233;todo que recibe un veh&#237;culo puede recibir una moto porque esta es un veh&#237;culo y se hace un upcasting imediatamente<br>aunque enviemos sin upcasing primero <em>moto m = new moto()</em><br><br><strong>Clase Object</strong><br>Todas las clases en Java son subclases de la clase Object, y heredan los metodos<br><u>equals(</u>) y <u>toString()</u>, los cuales deberemos sobreescribir para realizar comparacin<br><br><strong>Clases Abstractas</strong><br>Las clases abstractas dejan m&#233;todos abrtractos sin definir, para que sus subclases manejen cada una por separado la funci&#243;n de los m&#233;todos. Un metodo abstracto debe ser definido en la subclase de la clase abstracta.<br><br>-------------------------------------------------------------<br><br><strong><u>CLASE 3:</u></strong><br><br><strong>Listas</strong> (las diapositivas estan bastante completas):<br><br>Listas comienzan en la posicion 1 (no como los arreglos que comienzan en la pos 0)<br><br>Al pasar par&#225;metros a los m&#233;todos de la lista, debe hacerse una distinci&#243;n entre int para hablar de posici&#243;n e Integer (clase wrapper) para hablar de contenido de la lista (si es que se hace una lista de enteros).<br><br><ul class="bullet"><li>arreglo[i++] = incremento post-fijo, devuelve el valor en i, y luego aumenta el valor de i</li><li>arreglo[++i] = incremento pre-fijo, aumenta el valor de i, y luego devulve el valor en i</ul><br><strong>Generalizando estructuras:</strong><br>Proporciona la posibilidad de tener una implementacion gen&#233;rica (permitiendo as&#237; una mayor flexibilidad) , y una instanciacion homogenea.<br><br><strong>Constructores</strong><br>No son m&#233;todos.<br>Si hay un constructor implicito con par&#225;metros, el default no puede invocarse.<br>Con el this() se puede invocar a otro constructor, y se identifica a travez de los paremetros que se le manda (siempre esta en la primera linea del constructor que lo utiliza).<br><br>-------------------------------------------------------------<br><strong><u>CLASE 4 (01&#x2F;04):</u></strong><br><br><strong>Estructura de datos:</strong> Forma de almacenar y organizar datos para facilitar su acceso y modificaci&#243;n.<br><br>Si hay que analizar el peor caso para encontrar un valor en un arreglo ordenado realizando una b&#250;squeda binaria, hay que hacer:<br>log2(n) + 1 = cantidad de elementos a analizar<br><br>-------------------------------------------------------------<br><br><strong><u>CLASE 5 (07&#x2F;04):</u></strong><br><br><strong>Familia arb&#243;lica: </strong>Ra&#237;z -&gt; Padre -&gt; Hijo - Hoja<br><ul class="bullet"><li>Las hojas son nodos que no tienen hijos :c</ul><br><strong>DEFINICIONES:</strong><br><strong>Altura</strong>: Es la longitud del <u>camino m&#225;s largo</u> desde un nodo hasta una hoja.<br><ul class="bullet"><li>Las hojas tienen altura 0.</li><li>La altura de un &#225;rbol es la altura del nodo ra&#237;z.</ul><strong>Profundidad</strong>: Es la longitud del <u>&#250;nico camino</u> dsede la ra&#237;z hasta un nodo.<br><ul class="bullet"><li>La ra&#237;z tiene profundidad 0.</ul><strong>Grado</strong>: Cantidad de hijos de un nodo.<br><br><strong>&#193;RBOL BINARIO:</strong><br><strong>Grado m&#225;ximo de sus nodos:</strong> 2.<br><strong>&#193;rbol binario lleno</strong>: Todos los nodos tienen grado 2 y las hojas est&#225;n a la misma altura.<br><strong>&#193;rbol binario completo:</strong> &#193;rbol binario lleno hasta h-1 y el nivel h se completa de izquierda a derecha.<br><ul class="bullet"><li>La cantidad de nodos en un &#225;rbol binario completo var&#237;a entre 2^h y [2^(h+1)] - 1.</ul><br><strong>RECORRIDOS:</strong><br><strong>Preorden</strong>: Ra&#237;z, Hijo Izquierdo, Hijo derecho.<br><strong>Inorden</strong>: Hijo Izquierdo, Ra&#237;z, Hijo derecho.<br><strong>Postorden</strong>: Hijo Izquierdo, Hijo derecho, Ra&#237;z.<br><strong>Por nive</strong>l: Ra&#237;z, nivel 1, nivel 2, nivel ..., nivel h.<br><br><strong>&#193;RBOL DE EXPRESI&#211;N:</strong><br>Es un &#225;rbol binario asociado a una expresi&#243;n aritm&#233;tica:<br><ul class="bullet"><li>Nodos internos: Representan operadores (+, -, *, &#x2F;, etc.)</li><li>Hojas: Representan operandos (n&#250;meros, variables, etc.).</ul><br>Seg&#250;n la notaci&#243;n, se los conoce como:<br><ul class="bullet"><li><strong>Expresi&#243;n Infija:</strong> Operadores entre operandos.<ul class="bullet"><li>Se usa una pila y se tiene en cuenta la precedencia de los operadores.</ul><li><strong>Expresi&#243;n Posfija:</strong> Operadores despu&#233;s de los operandos.</li><li><strong>Expresi&#243;n Prefija:</strong> Operadores antes de los operandos.</ul>-------------------------------------------------------------<br><br><strong><u>CLASE 6 (08&#x2F;04):</u></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Vimos implementaci&#243;n y ejemplos de &#193;rbol binario y &#193;rbol de expresi&#243;n.<br><br>-------------------------------------------------------------<br><br><strong><u>CLASE 7 (14&#x2F;04):</u></strong><br><br>Infija -&gt; Postfija -&gt; &#193;rbol -&gt; Prefija<br><br><strong>&#193;RBOLES GENERALES:</strong><br><strong>Definiciones:</strong><br><ul class="bullet"><li><strong>Grado</strong>: N&#250;mero de hijos de un nodo.<ul class="bullet"><li><strong>Grado del &#225;rbol</strong>: Grado del nodo con mayor grado.</ul><li><strong>Altura: </strong>Es la longitud del <u>camino m&#225;s largo</u>desde un nodo hasta una hoja.<ul class="bullet"><li>Las hojas tienen altura 0.</li><li>La altura de un &#225;rbol es la altura del nodo ra&#237;z.</ul><li><strong>Profundidad: </strong>Es la longitud del <u>&#250;nico camino</u>dsede la ra&#237;z hasta un nodo.<ul class="bullet"><li>La ra&#237;z tiene profundidad 0.</ul></li></ul><br><strong>&#193;rbol general lleno: </strong>Es un &#225;rbol general de grado k, para el cual todos sus nodos tienen grado k o son hojas, y todas las hojas est&#225;n a la misma altura.<br><ul class="bullet"><li><strong>F&#243;rmula cantidad de nodos:</strong> Sumatoria desde j = 0 hasta h, de k^j</ul><br><strong>&#193;rbol general completo: </strong>Es un &#225;rbol general de altura h y grado k, que es lleno hasta la altura h-1 y se completa de izquierda a derecha en la altura h.<br><ul class="bullet"><li><strong>F&#243;rmula cantidad de nodos:</strong>&nbsp;<ul class="bullet"><li>Cantidad m&#237;nima: (Sumatoria desde j = 0 hasta h-1, de k^j) + 1</li><li>Cantidad m&#225;xima: Sumatoria desde j = 0 hasta h, de k^j</ul></li></ul><br>-------------------------------------------------------------<br><br><strong><u>CLASE 8 (15&#x2F;04):</u></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>&#193;rboles generales</strong>, implementaci&#243;n.<br><br>&#193;rbol general, tiene un dato privado &quot;ra&#237;z&quot; de tipo Nodo General.<br>El nodo general guarda su dato y una lista generica con sus hijos.<br><br><u>El &#225;rbol general es representado internamente con nodos generales genericos, pero desde fuera solo deben verse &#193;rboles Generales</u> (los m&#233;todos deben devolver &#193;rboles, se debe crear como un &#193;rbol, etc.)<br><em>(El arbol funciona como &quot;wrapper&quot; de los nodos)</em><br><br><strong>Constructores</strong>:<br>&nbsp;&nbsp;&nbsp; <em>&#193;rbolGeneral&lt;T&gt;(T dato)</em>: Instancia la ra&#237;z con el dato.<br>&nbsp;&nbsp;&nbsp; <em>&#193;rbolGeneral&lt;T&gt;(T dato, hijos)</em>: Recibe la ra&#237;z y la lista de hijos (los hijos es una lista de &#193;rbolesGenerales). Recupera la ra&#237;z de cada hijo y la guarda como dato en cada nodo de una lista de NodosGenerales.<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><u>Recorridos:</u></strong><br>&nbsp;&nbsp;&nbsp; <strong>Preorden</strong>: Devuelve una ListaEnlazadaGen&#233;rica de los datos del &#193;rbol (en Preorden).<br>M&#233;todo recursivo:&nbsp;<br><ol class="number"><li>Guarda dato ra&#237;z en la lista.</li><li>Crea Lista de hijos.</li><li>Mientras tenga hijos, llama a Preorden con cada hijo.</ol><br>-------------------------------------------------------------<br><br><strong><u>CLASE 9 (21&#x2F;04):</u></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>COLA DE PRIORIDADES:</strong><br><strong>Definici&#243;n: </strong>Estructura de datos que permite al menos dos operaciones:<br><ul class="bullet"><li><strong>Insert</strong>: Inserta un elemento en la estructura.</li><li><strong>DeleteMin:</strong> Encuentra, recupera y elimina el elemento m&#237;nimo.<ul class="bullet"><li>El elemento de prioridad m&#225;s alta tiene prioridad 0.</ul></li></ul><br><strong>Aplicaciones:</strong><br><ul class="bullet"><li>Cola de impresi&#243;n</li><li>Sistema Operativo</li><li>Algoritmos de Ordenaci&#243;n</ul><br>-------------------------------------------------------------<br><br><strong><u>CLASE 10 (28&#x2F;04):</u></strong><br><br><strong>Ordenar un arreglo usando una Heap (V1).</strong><br><ol class="number"><li>Construir una MinHeap con todos los elementos a ordenar.</li><li>Sacar todos los elementos de la MinHeap y guardarlos en el vector.</ol><br>Como la MinHeap ya est&#225; ordenada de menor a mayor, salen en orden.<br><br><strong>Algoritmo HeapSort:</strong><br>Menor a mayor: Usa MaxHeap.<br>Mayor a menor: Usa MinHeap.<br><br><ol class="number"><li>Crear una MaxHeap con los elementos a ordenar.</li><li>Intercambiar el &#250;ltimo elemento de la MaxHeap con la ra&#237;z.</ol><ul class="bullet"><li><ul class="bullet"><li>Se pierde propiedad del orden de la MaxHeap.</ul></li></ul><ol class="number"><li>Reducir en 1 el tama&#241;o de la MaxHeap.</li><li>Hacer filtrado hacia abajo de la ra&#237;z.</ol><ul class="bullet"><li><ul class="bullet"><li>Recuperar propiedad de orden de la MaxHeap.</ul></li></ul><ol class="number"><li>Volver al paso 2 hasta tener una MaxHeap de tama&#241;o 1.</ol><br><strong>CONSTRUIR UNA HEAP:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>Insertar de a 1: O(n.Log(n)):</strong><br><ol class="number"><li>Agrega un elemento.</li><li>Filtra hacia arriba.</li><li>Agrega el siguiente elemento.</ol>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>BuildHeap: O(n)</strong><br><ol class="number"><li>Colocar elementos en el orden que llegan, todos juntos.&nbsp;</li><li>Desde la mitad hacia atr&#225;s, filtra hacia abajo.</ol><br><br><strong>INTERFACES:</strong><br>Son una colecci&#243;n de definiciones de m&#233;todos sin implementaci&#243;n y constantes.<br>Proporcionan un mecanismo para que una clase defina un comportamiento de un tipo de datos diferentes al de su superclase<br><br>-------------------------------------------------------------<br><br><strong><u>CLASE 11 (29&#x2F;04):</u></strong><br><br><strong>COMPARABLE:</strong><br>objeto1.CompareTo(Objeto2) devuelve un Entero.&nbsp;<br><ul class="bullet"><li>Si es positivo: Objeto1 &gt; Objeto2</li><li>Si es negativo: Objeto1 &lt; Objeto2</li><li>Si es 0: Objeto1 = Objeto2</ul><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong><em>class </em></strong><em>nombreClaseGenerica&lt;T <strong>extends </strong>nombreInterface&lt;T&gt;&gt;</em><br><br>La clase nombreClaseGenerica solo acepta datos de tipo<em>T</em> si el tipo <em>T</em> implementa la Interface <em>nombreInterface.</em><br><br>Por ejemplo:<br><strong><em>class </em></strong><em>ArbolBinarioDeBusqueda&lt;T <strong>extends </strong>Comparable&lt;T&gt;&gt;{</em>...<em>}</em><br><br>-------------------------------------------------------------<br><br><strong><u>CLASE 12 (05&#x2F;05):</u></strong><br><br><strong>PARCIAL (Parte te&#243;rica):</strong><br>&nbsp;&nbsp;&nbsp; <u>S&#225;bado 16&#x2F;05: 09:00.</u><br>&nbsp;&nbsp;&nbsp; Multiple Choice a trav&#233;s de C&#225;tedras<strong>&nbsp;</strong><br><br><strong>PARCIAL (Parte pr&#225;ctica):</strong>&nbsp;<br>&nbsp;&nbsp;&nbsp; <u>S&#225;bado 16&#x2F;05: 16:00.</u><br>&nbsp;&nbsp;&nbsp; Rinden todos en simult&#225;neo<br>&nbsp;&nbsp;&nbsp; Temas:&nbsp;<br>&nbsp;&nbsp;&nbsp; Hasta Heap incluido<br><br><strong>CONSULTA (teor&#237;a):</strong><br>&nbsp;&nbsp;&nbsp; Viernes 8&#x2F;5 y 15&#x2F;5, 16:30<br><br>---------------------------------------------------------------<br><br><strong><u>CLASE 13 (12&#x2F;05):</u></strong><br><br><strong>REPASO:</strong><br>Recorridos en el &#225;rbol de la teor&#237;a 7 (&#193;rboles Generales: definici&#243;n, representaciones y recorridos).<br><br><br><strong>PreOrden:</strong><br>A, B, D, E, J, Q, K, R, C, G, L, M, N, H, &#209;, O, P, I<br><strong>InOrden:</strong><br>D, B, Q, J, E, R, K, F, A, L, G, M, N, C, &#209;, H, O, P, I<br><strong>PostOrden:</strong><br>D, Q, J, R, K, E F, B, L, M, N, G, &#209;, O, P, H, I, C, A<br><br><br><strong>CONSTRUIR HEAP:</strong><br><ul class="bullet"><li>| 3 | 8 | 2 | 5 | 1 |</ul>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>BuildHeap:</strong> O(n)<br><ul class="bullet"><li>| 1 | 3 | 2 | 5 | 8 |</ul><strong>Inserci&#243;n de a 1:</strong> O(n.Log(n))<br><ul class="bullet"><li>| 1 | 2 | 3 | 8 | 5 |</ul><br>* Agregu&#233; resumen de c&#243;mo construir la Heap de ambas formas en la Clase 10.<br><br>---------------------------------------------------------------<br><br><strong>CLASE 16 (02&#x2F;06):</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>Grafos de relaciones entre actores: <a href="https&#x3a;&#x2F;&#x2F;oracleofbacon&#x2e;org&#x2F;" rel="noreferrer noopener">https:&#x2F;&#x2F;oracleofbacon.org&#x2F;</a><br><br><strong>Definiciones:</strong><br><ul class="bullet"><li><strong>Grafo</strong>: Modelo para representar relaciones entre elementos de un conjunto.</li><li><strong>Grafo (V, E):</strong><ul class="bullet"><li>V es un conjunto de v&#233;rtices o nodos con una relaci&#243;n entre ellos.</li><li>E es un conjunto de pares (u, v), tales que u, v pertenecientes a V, llamados aristas o arcos.</ul><li><strong>Grafo dirigido</strong>:&nbsp; La relaci&#243;n sobre V no es sim&#233;trica ... (no termin&#233; de copiar)<ul class="bullet"><li>Ejemplo: Seguidores de Instagram.</ul><li><strong>Grafo no dirigido</strong>: (no termin&#233; de copiar)<ul class="bullet"><li>Ejemplo: Amigos de Facebook.</ul><li>V es <strong>Adyacente </strong>a U si existe una arista (u, v) perteneciente a E.<ul class="bullet"><li>Grafo dirigido: (u, v) perteneciente a E, incide en v y parte de u.</li><li>Grafo no dirigido: (u, v) perteneciente a E, incide en los nodos u, v.</ul><li><strong>Grado</strong>:<ul class="bullet"><li><u>Grafo no dirigido</u>:<ul class="bullet"><li>Grado de un nodo: N&#250;mero de nodos que inciden en &#233;l.</ul><li><u>Grafo dirigido</u>:<ul class="bullet"><li>Existe Grado de Salida (out)<ul class="bullet"><li>N&#250;mero de arcos que parten de &#233;l.</ul><li>Existe Grado de Entrada (in)<ul class="bullet"><li>N&#250;mero de arcos que inciden en &#233;l.</ul><li>Grado del v&#233;rtice: Suma de los grados in y out.</li><li>Grado del grafo: M&#225;ximo grado de sus v&#233;rtices.</ul></li></ul><li><strong>Camino</strong>: Igual que en &#225;rboles, b&#225;sicamente.<ul class="bullet"><li>Longitud de un camino: N&#250;mero de <u>arcos</u> del camino.</li><li>Camino simple: Camino en el que todos sus v&#233;rtices son distintos, excepto, tal vez, el primero y el &#250;ltimo.</ul><li><strong>Ciclo</strong>: Camino que empieza y termina en el mismo nodo.<ul class="bullet"><li>Es simple si el camino es simple.</ul><li><strong>Bucle</strong>: Ciclo de longitud 1.</li><li><strong>...</strong></li><li><strong>Subgrafo</strong>: Un subconjunto de v&#233;rtices y aristas del grafo original.<ul class="bullet"><li><strong>Subgrafo inducido:</strong> Subgrafo que incluye <u>TODAS </u>las aristas que conectan a los v&#233;rtices en el grafo original.</ul><li><strong>Grafo ponderado</strong>, pesado o con costo:<ul class="bullet"><li>Cada arco o arista tiene asociado un valor o etiqueta.</ul></li></ul><br><strong>Conectividad</strong>:<br><ul class="bullet"><li>Grafo no dirigido:<ul class="bullet"><li>Es conexo si hay un <u>camino </u>entre cada par de v&#233;rtices.</li><li>Bosque: Grafo no dirigido sin&nbsp; ciclos.</li><li>&#193;rbol libre: Bosque conexo.</li><li>&#193;rbol: &#225;rbol libre en el que se ha designado un nodo como ra&#237;z.</ul><li>Grafo dirigido:<ul class="bullet"><li>Fuertemente conexo: Existe un camino desde cualquier v&#233;rtice hasta cualquier otro v&#233;rtice.</li><li>D&#233;bilmente conexo: El grafo no es fuertemente conexo y el grafo subyacente (sin sentido en los arcos) es conexo.</li><li>No conexo.</ul></li></ul>
</body>
</html>
